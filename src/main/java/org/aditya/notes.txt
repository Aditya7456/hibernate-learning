HQL - Hibernate Query Language
* we need this when we want to filter the data based on some complex variable,
* offcourse we can use SQL also in that case it is called native query,
* so here we will use HQL.

like in sql if we want to select all data -> select * from student;
in sql we use tablename
but in hql if we want to select all data -> from Student;
in hql we use entity or ClassName

* in jdbc query result gives us resultSet
* in hibernate query return the resultList of entity type only

/* Eager loading -> session.get(Laptop.class, 1);
    * it will load data even if we print or not.
/* Lazy Loading ->  session.getReference(Laptop.class, 1);
    * it will now load data until we use it.

----------------------------    Hibernate Cache ----------------------------
ğŸ§  What is Hibernate Cache?
Hibernate cache stores database data in memory to:
    *Reduce DB hits
    *Improve performance
    *Speed up applications

Hibernate has 2 cache levels:

ğŸ”¹Level 1 Cache (L1) â€“ Default
    Session â†’ L1 Cache â†’ Database
    Session session = sessionFactory.openSession();

    Laptop l1 = session.get(Laptop.class, 1); // DB hit
    Laptop l2 = session.get(Laptop.class, 1); // NO DB hit (from L1)

    session.close();
    âœ” Second call is served from L1 cache

    **Important points (INTERVIEW GOLD)
        *Exists only while session is open
        *Cleared when session closes
        *Prevents duplicate DB calls in same transaction
        *Always ON
    ğŸ”¹ When L1 cache is cleared
        session.clear();   // clears entire cache
        session.evict(obj); // removes specific object

ğŸ”¹Level 2 Cache (L2) â€“ Optional
    2ï¸âƒ£ Level 2 Cache (Second-Level Cache)
    ğŸ”¹ What it is
        Cache shared across sessions
        Optional
        Needs external providers
    ğŸ”¹ Scope
        ğŸ‘‰ SessionFactory-wide
        Session1 â”
        Session2 â”œâ”€â†’ L2 Cache â†’ Database
        Session3 â”˜

        Session session1 = sessionFactory.openSession();
        Laptop l1 = session1.get(Laptop.class, 1); // DB hit â†’ stored in L2
        session1.close();

        Session session2 = sessionFactory.openSession();
        Laptop l2 = session2.get(Laptop.class, 1); // NO DB hit (from L2)
        âœ” Data reused across sessions

    ğŸ”¹ Cache Providers
        Common ones:
            *Ehcache
            *Hazelcast
            *Infinispan
            *Redis (via integration)

    ğŸ”¹ Enable L2 Cache (example)
        spring.jpa.properties.hibernate.cache.use_second_level_cache=true
        spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory

    ğŸ”¹ Entity-level annotation
        @Entity
        @Cacheable
        @org.hibernate.annotations.Cache(
            usage = CacheConcurrencyStrategy.READ_ONLY
        )
        public class Laptop {
        }

    ğŸ”„ Cache Flow (Very Important)
        Request
         â†“
        Level 1 Cache (Session)
         â†“
        Level 2 Cache (SessionFactory)
         â†“
        Database

        * Hibernate always checks L1 â†’ L2 â†’ DB

        | Feature          | Level 1 Cache    | Level 2 Cache  |
        | ---------------- | ---------------- | -------------- |
        | Default          | âœ… Yes            | âŒ No           |
        | Scope            | Session          | SessionFactory |
        | Shared           | âŒ No             | âœ… Yes          |
        | Config needed    | âŒ No             | âœ… Yes          |
        | Performance gain | Medium           | High           |
        | Use case         | Same transaction | High-read apps |

        â— Why NOT cache everything?
            Bad candidates:
            Frequently changing data
            Large tables
            Transactional records
            Good candidates:
            Master data
            Lookup tables
            Read-heavy entities
* to use l2 cache we manually need to manually implement it
1.